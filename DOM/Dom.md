# Dom

### 简介 ：document object model：**文档对象模型** 

![1675490099217](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675490099217.png)

![1675490115724](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675490115724.png)

1. **获取元素**

   > 1. id获取： **document.getElementById("id名")** 
   > 2. 标签获取：**document.getElementsByTagName("标签名")** 
   >    * 因为有多个标签（或者只有一个标签元素）：返回都是以伪数组形式存储
   >    * 打印里卖弄的元素使用遍历进行查找：或者变量.下标查看
   >    * 页面没有可获取元素：返回空的伪数组
   >    * 指定父元素下的标签
   >      1. * 标签获取父元素标签
   >         * 再查找：第几个父元素变量[伪书组下标].获取标签
   >      2. * 设置id获取指定id标签元素
   >         * 再进行直接查找：获得的父元素.获取标签元素
   > 3. 类名获取（H5新增）：**document.getElementsByClassName** 
   >    * 返回取相同类名的元素集合（伪数组）
   > 4. 万能获取元素：
   >    * 返回第一个指定元素： **document.querySelector("选择器（注意选择器是什么前面就添加什么符号）")**  
   >    * 返回所有相同指定元素（伪书组形式）： **document.querySelectorAll("选择器（注意选择器是什么前面就添加什么符号）")**  
   > 5. 获取特殊元素
   >    * 获取body：**document.body**
   >    * 获取html：**document.documentElement**

2. 事件

   > 1. 事件三要素：
   >    1. 事件源：时间被触发的对象：例如按钮
   >    2. 事件类型：鼠标出动、轮滑出动、键盘键入
   >    3. 事件处理程序：通过函数赋值形式完成
   > 2. 事件步骤：
   >    1. 获取事件源
   >    2. 注册事件
   >    3. 函数赋值处理

3. 操作元素基础

   > 1. **改变元素内容：** 
   >
   >    1. innerText：修改里面文本内容
   >
   >       1. 不识别html标签
   >          * 如果直接赋值内容带有html标签会连标签一块返回
   >          * 在html结构中的标签会一行显示：忽略空格和回车
   >       2. 使用较少
   >       3. 案例：点击获得当前时间
   >          * 先进行获取元素
   >          * 注册事件：btn点击之后=函数输出{div.innerHTML = 调用函数}
   >          * 函数（注意如果是匿名函数的位置） 获取当前时间{先进性new Date（）；格式化年月日天，最后返回：拼接年月日天}
   >       4. 案例：直接修改（不需要刷新和点击）
   >          * 直接获取元素
   >          * 元素.innerHTML = 调用以上函数
   >
   >    2. innerHTML
   >
   >       1. 可以识别html元素
   >
   >          * 如果直接赋值内容带有html标签会使用标签后一块返回
   >
   >          * 在html结构中的标签会保留html键入内容显示：空格和回车
   >
   >       2. 使用较多
   > 2. **修改元素路径** ：src、href、url、title。。（键值对形式出现）
   >
   >    1. 案例：点击切换图片
   >       * 获取两个点击按钮+获取图片
   >       * 注册点击事件
   >       * 函数处理程序赋值给事件{图片路径="修改后的路径"}
   >    2. 案例：分时显示对应
   >       * 获取元素（图片+内容标签）
   >       * 获取当前时间
   >       * 利用分支划分早中晚{并进行赋值操作更换图片和内容}
   > 3. **修改表单元素** ：
   >
   >    1. 案例：点击之后表单内容元素修改
   >       1. 获取点击和表单
   >       2. 注册事件：鼠标点击按钮事件
   >       3. 赋值函数程序{表单.value = "修改value值"  this.disabled = true事件禁用}
   >    2. 案例：密码可见案例
   >       1. 编写结构样式
   >       2. 获取元素（图片、input）
   >       3. 添加一个事件次数判断值初始化为0
   >       4. 注册事件“：鼠标点击图片事件  = { 如果还没点击：眼睛路径更换+type属性更换成text并更换判断值，如果点击了：再次更换眼睛路径+type属性到passward并更换判断值}
   > 4. **样式操作** 
   >    1. 通过js修改大小、颜色、位置等
   >    2. 修改较少样式：element.style
   >    3. 修改较多样式：在注册函数下进行：this。element.className = '类名'
   >    4. **案例** ：点击消失二维码
   >       1. 布局二维码+小叉号样式
   >       2. 获取叉号和大盒子元素
   >       3. 小叉号点击事件=大盒子消失：display：none
   >    5. **案例：精灵图循环**
   >       1. 布局好样式：多个li先设置背景色
   >       2. 获取所有的li
   >       3. 循环遍历
   >       4. 设置每一个小图之间关系的变量赋值表达式
   >       5. 直接位置复制操作
   > 5. **新增事件：获取焦点+失去焦点**
   >    1. 获取焦点：onfocus
   >    2. 失去焦点：onblur
   >    3. **案例：显示文本框内容** ：
   >       1. 获得文本框元素
   >       2. 注册获取焦点事件：判断
   >          1. 如果默认value值是‘指定的值’
   >          2. this.value = ''
   >          3. 否则是其他颜色
   >       3. 注册 焦点失去事件：判断
   >          1. 如果默认值是空
   >          2. this,value = '指定值'
   >          3. 否则颜色修改成浅色

4. 复杂操作元素

   > 1. **排他思想：（搭配内循环）** 
   >    1. 多个按钮点击变色，到那时每次哪个变色，其他按钮百年色都消失
   >    2. 获取所有按钮
   >    3. 遍历按钮
   >       1. 注册事件：每次点击时候
   >          1. 循环按钮
   >          2. 设置成所有按钮背景颜色为空
   >       2. 事件程序颜色是红色
   > 2. **案例-百度换肤** 
   >    1. 布局简易样式：四张图+body背景
   >    2. 获取图片元素
   >    3. 注册时间
   >       1. 遍历图片
   >       2. 注册点击事件
   >       3. 获取body元素样式背景图 赋值成图片路径（注意拼接）
   > 3. **新增事件:鼠标经过+鼠标离开** 
   >    1. **案例-鼠标经过表格行变色**
   >       1. 布局好结构样式
   >       2. 获取行元素
   >       3. 遍历行
   >          1. 设置鼠标经过事件
   >          2. 使用样式className进行赋值背景颜色
   >          3. 设置鼠标移除事件
   >          4. 使用样式className进行赋值背景颜色
   > 4. **表单全选**
   >    1. 全选和取消全选功能
   >       1. 以id命名方式获取全选框：在thead中tr中th中的iput
   >       2. 以id名获取tbody并进行获取unput标签
   >       3. 遍历input
   >       4. 注册全选框点击事件：
   >          1. 遍历多选框 并进行赋值每一个多选框的checked=全选框的checked（注意相等的是返回值）
   >    2. 多选框全部选中全选框也会选中功能
   >       1. 因为有以上获取元素
   >       2. 直接遍历多选框
   >       3. 给多选框注册点击事件：
   >          1. 注意声名一个flag布尔值默认true
   >          2. 再次循环单选框
   >          3. 判断：如果未点击：flag=false
   >       4. 全选框.checked属性 = flag（默认值）
   > 5. **自定义属性操作** 
   >    1. *获取属性* 
   >       1. 获取元素内置属性：element.属性  
   >       2. 获取元素自定义属性：
   >          1. element.getAttribute('属性')
   >          2. element.dataset.属性（直接表明是自定义属性）
   >    2. 设置属性
   >       1. element.属性 = '值'
   >       2. element.setAttribute('属性名','属性值')：一般属性名采用data-name,属性值（搭配上面的dataset进行获取自定义属性）
   >    3. 移除属性：element.removeAttribute('属性')
   >    4. **案例：tab栏切换**
   >       1. 布局页面：大盒子（列表栏+内容都定义好类名）
   >       2. 获取元素：列表、列表中的所有li；内容
   >       3. 排他思想：遍历lis并设置背景名属性更改为空；留下自己设置好背景命（css提前设置好）
   >       4. 给lis创建新属性并赋值：对应循环的值
   >       5. 获取到lis新增属性的索引号（因为实在lis'循环里面，所以相等）
   >       6. 排他思想：
   >          1. 变量内容元素
   >          2. 所有内容样式为隐藏
   >          3. 遍历外：指定与lis[index]队形的内容样式属性为显示

5. **节点**（兼容性差）

   > 1. **介绍** ：亲近于dom提供的获取元素的方法![img](https://cdn.nlark.com/yuque/0/2023/png/33610899/1675595325429-18ddab83-cd97-442d-a1af-938f4faed74d.png)
   >    * 所有的内容都是节点
   >    * 有节点类型、节点名称、节点值
   >    * 节点类型：元素类型：1、属性类型：2、文本类型：3
   >    * 用node来表示
   > 2. **节点使用** 
   >    1. **获取父节点**（亲爸爸）node.parentNode
   >
   >    2. **获取子节点**：
   >    
   >       1. 标准：parentNode.childNode
   >          * 缺点：获取到子级所有元素：包括文本元素
   >          * 其次：还要搭配封装：遍历子元素：判断如果type属性是1然后进行返回
   >       2. **非标准：parentNode.children**
   >          * 只返回子元素节点
   >       3. **案例:点击下拉菜单**
   >          1. 布局页面：区分a链接和内容  多个ul并排排列
   >          2. 获取到元素大盒子
   >          3. 获取nav的子盒子li（案例：四个）
   >          4. 遍历lis 
   >          5. 注册点击事件
   >          6. 注意：一开始默认是li下面的ul隐藏，所以不会有点击
   >          7. 鼠标移动到哪个li上去：就给第一个孩子ul设置显示
   >          8. 在设置鼠标移除：就给第一个个孩子设置隐藏
   >    
   >    3. **获取指定子节点**
   >    
   >       1. 获取节点：
   >          * 第一个：parentNode.firstchild
   >          * 最后一个：parentNode.lastchild
   >       2. 开发使用-获取最后一个元素节点：parentNode.[parentNode.children.length-1]
   >    
   >    4. **获取兄弟节点**
   >
   >       1. 下一个兄弟节点：node.nextSibling
   >       2. 上一个兄弟节点：node.previousSibling
   >       3. 上一个元素节点：node.nextElementSibling
   >       4. 上一个元素节点：node.previousElementSibling
   >
   >    如果没有兄弟：返回一null
   >
   >    5. **创建节点**
   >
   >       1. 创建节点:document.createElement('元素')
   >       2. 放到父节点最后面（相当于push）
   >          1. 父节点.appendChild(li)
   >       3. 放到指定元素前面
   >          1. 父节点.indertBefore(添加元素，指定父亲的孩子位置)
   >       4. **案例-文本框上传**
   >          1. 获取元素：文本框、按钮、空的ul
   >          2. 给按钮设置点击事件
   >             1. 判断：
   >                * 如果文本框value值是‘’：输出你没输出内容：并返回false
   >                * 如果文本框有内容
   >                  * 创建节点
   >                  * 给节点内容赋值输入的text.value
   >                  * 添加节点放在父级节点的子节点最前面
   > 6. 删除节点：父节点.removeChild(父节点指定的字节点)
   >    
   >    1. **案例-删除评论**：以上案例作为基础
   >       2. 首先修改添加的评论内容内拼接一个a链接（防止跳转修改href：‘javascript : ;’）完整标签作为删除按钮：在li里面（注意放在添加节点的前面）
   >       3. 在添加节点后注册删除节点事件
   >          1. 因为已经添加节点
   >          2. 直接遍历a
   >          3. 注册点击事件
   >          4. 直接删除：因为是作为ul的孙子：所以使用ul移除孩子节点（当前按钮的父亲）
   >    7. **复制节点**
   >       1. 克隆：node.clonNode():
   >          1. 参数为true：深拷贝（克隆标签以及标签内容）
   >          2. 参数为空或者false:浅拷贝（只克隆标签）
   >    8. **案例-动态生成表格**
   >       1. 准备生成的数据存储在一个数组包含的对象里面
   >       2. 获取到表格body：进行遍历数组创建
   >          1. 创建空行
   >          2. 插入到tbody
   >          3. 再遍历对象（遍历一个数组就遍历一遍对象）
   >             1. 创建td内容=对象属性值
   >             2. 插入到行tr的后面
   >          4. 创建删除
   >          5. 复制内容=删除链接
   >          6. 插入到tr
   >       3. 注册删除事件：
   >          1. 获取所有a元素
   >          2. 遍历a：
   >          3. 指定a注册事件
   >          4. 父节点.删除孩子（孩子节点）
   >    9. 三种动态创建元素方式：
   >       1. element.innerHTML
   >          1. 使用数组形式追加拼接+（join）：效率最快
   >          2. 但是使用字符串拼接效率就比较低
   >       2. document.creatElement()
   >          1. 创建多个元素节点比innerHTML字符串创建速度快
   >       3. document.write()   不常用

6. **总结重点**

   1. 对元素的操作：增、删、改、查、属性操作、事件操作

      > 1. 创建
      >
      >    1. element.innerHTML = ''
      >    2. document.creatElement('tagName')
      >    3. document.write()  会导致页面重绘：不常用
      >
      > 2. 增加
      >
      >    1. 父node.appendChild(child)
      >    2. 父node.insertBefore(创建的，child)
      >
      > 3. 删除
      >
      >    1. 父node.removeChild(child)
      >
      > 4. 修改
      >
      >    1. 属性：src、href、title
      >    2. 普通内容：innerText\innerHTML
      >    3. 表单元素:value、type、disabled、checked
      >    4. 元素样式：style、clsaaName
      >
      > 5. 查找
      >
      >    1. DOM提供的id获取和标签获取
      >    2. H5新增类名获取和万能获取
      >    3. 利用节点查找：
      >       1. 父：childNode：parentNode（亲爸爸）
      >       2. 子：parentNode：children
      >       3. 兄弟：
      >          * node.nextElemenSibling
      >          * node.previousElemenSibling
      >
      > 6. 属性操作
      >
      >    1. 创建属性：
      >       1. 内置：元素.属性 = '属性值'
      >       2. 自定义：element.setAttribut（'属性名','属性值'）：一般是data-开头
      >    2. 获取属性：
      >       1. 内置：元素.属性
      >       2. 自定义element.getAttribut（'属性名'）
      >       3. element.data.属性/element.data['属性名']
      >    3. 移除属性：element.removeAttribute（'属性'）
      >
      > 7. 事件操作：
      >
      >    1. 目前主要是鼠标事件的注册使用：
      >
      >    2. 1. onclick  ：点击
      >       2. onmouseover ：经过
      >       3. onmouseout ：移除
      >       4. onfocus：获得焦点
      >       5. onblur :失去焦点
      >       6. onmousemove：移动
      >       7. onmouseup：弹起
      >       8. onmousedown：按下

### 高级事件

1. 注册事件：
   1. 传统注册：element.onclick = function(){}
      1. 缺点：初注册多个事件只会执行最后一个事件
   2. 监听注册(ie9以下不兼容)：element.addEventListener('click(没有on)',funnction(){})
      1. 优点：注册多个事件会以此执行
   3. 旧版本监听注册：element.attachEvent（'onclick',funnction(){}）
   4. 注意如果要兼容要添加兼容封装代码
   
2. 删除（解绑）事件
   1. 传统删除：element.onclick =null
   2. 删除监听(ie9以下不兼容):element.removeEventListener('click(没有on)',funnction(){})
   3. 旧版本删除监听：element.detachEvent（'onclick',funnction(){}）
   4. 删除监听事件的函数应该是单独封装的
   5. 注意如果要兼容要添加兼容封装代码
   
3. DOM事件流

   1. **阶段** 

      ![img](https://cdn.nlark.com/yuque/0/2023/png/33610899/1675744746117-51a5a99b-60db-42d7-a174-baf5e1135e03.png)

      1. 捕获阶段
         1. 当注册监听事件时候的第三个参数值：true
      2. 当前目标阶段
      3. 冒泡阶段
         1. 当注册监听事件时候的第三个参数值：没有或者false

4. 事件对象：

   1. **介绍**
      1. 监听事件中处理程序中的参数：event、ent、e
      2. 旧版本中的事件对象：window.event
   2. 事件对象的属性和方法
      1. **属性**
         1. 返回触发对象：e.target
         2. 返回事件绑定对象：this = e.currentTarget
         3. 返回事件类型：e.type
      2. **方法** 
         1. 阻止默认事件（例如暂停某种行为）：
            1. 高版本：e.preventDefault();
            2. 低版本：e.returnValue
            3. 不常用：return false（因为会出现中断js语句）
   3. 阻止冒泡：
      1. 高版本：e.stopPropagation()
      2. 低版本：e.cancleBubble = true
      3. 此处注意兼容

5. 事件委托

   1. 不用每个节点添加监听事件
   2. 配合e.target属性：

6. 禁止选中

   1. 禁止右键菜单：contextmenu(右键显示事件)        e.preventDefault()
   2. 禁止文本选中: selectstart(文本无法选中)       e.preventDefault()

7. 鼠标时间对象

   1. 可视区域坐标
      1. X轴：e.clientX
      2. Y轴：e.clientY
   2. 文档页面范围
      1. X轴：e.pageX
      2. Y轴：e.pageY
   3. 文档页面范围
      1. X轴：e.screenX
      2. Y轴：e.screenY
   4. 案例-鼠标跟随移动：
      1. 首先给图片设置绝对行为（显示在图层是最上面）
      2. 鼠标移动事件
      3. 获取在也买你可视区域的坐标值
      4. 进行赋值给top和left值

8. 常用键盘事件

   1. keyup：键盘弹起来
   2. keydown：键盘按下
   3. keypress：键盘按下（不识别功能键）
   4. 执行顺序：keydown 、 keypress  、keyup

9. 键盘对象事件

   1. 获取按下键的ASCII值：keyCode
   2. 严格区分大小写
   3. 键入事件：keypress也是会区分大小写：keydown和keyup就不区分大小写

10. 案例-键盘键入获取焦点（京东）

    1. 监听事件键盘弹起keyup
    2. 测试获取到指定键的ASCII值
    3. 判断如果键入值===测试所得值
    4. 调用鼠标集中内置方法

11. 案例-京东输入单号放大

    1. 小三角样式
       1. 给要添加的元素添加伪类
       2. 内容为空、宽高为0
       3. 位置绝对定位设置好位置
       4. 设置border宽度为零  不现实的颜色部分为透明transprent
    2. 检测键入监听
       1. keyup检测
          1. 如果有内容显示放大区域+显示输入内容
          2. 如果没有键入则不显示
    3. 失去焦点监听：隐藏放大区域
    4. 获得焦点监听：判断是否有内容，有内容再显示

    