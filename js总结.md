# js总结

1. 变量

   > var 声明变量；prompt输入;alert输出语句;console.log控制台；
   >
   > 1. 一个声名后面：多个变量初始化用逗号隔开
   > 2. 声明未赋值：未定义
   > 3. 不声名直接赋值
   > 4. 变量名使用 字母、数字、_$;

2. 数据类型

   > typeof检测数据类型；isNAN判断非数值；
   >
   > 1. 数字类型
   >    1. num、PI、八进制、16进制、最大值、最小值、无穷值、非数值
   > 2. 字符串类型
   >    1. 转义符:\n换行；\t缩进；\b空格
   >    2. 字符串长度、字符串拼接（引引加加）
   > 3. 布尔和空
   >    1. true运算是1、false运算是0
   >    2. false拼接字符串就是字符串、拼接数值就是非数值类型
   >    3. null拼接字符串是null字符串、拼接数值就是数值
   > 4. 检测数据类型
   >    1. 注意：输入数值检测说出来的数据类型是字符串类型
   > 5. 字面量
   >    1. 直接可以通过数据进行判断数据类型
   > 6. 数据类型转换
   >    1. 转换成字符串：变量.toString() 、String(变量) 、变量+""
   >    2. 转换成数值类型：
   >       1. parseInt/Float（数字字符串）生成数值类型；
   >       2. parseInt/Float（字符串非数字）生成 NAN ；
   >       3. Number（字符串）
   >       4. 隐式转换：（  -  /  *）字符串类型直接计算；
   >    3. 转换成布尔类型：Boolean（变量或者其他数据类型）
   >       1. 注意当：  ""  0   NAN  null undefined     出现时候布尔值时false；

3. 运算符

   **运算符优先级** 

   ![img](https://cdn.nlark.com/yuque/0/2022/png/33610899/1668825079281-2b0e78bc-822e-4ee3-98ed-5d90152662c5.png)

   > 1. 算数运算符：  +  -  *  /   == （注意使用运算符运算小数之后不可以直接判断）
   > 2. 递增运算符： 
   >    1. ++变量：先自增再返回
   >    2. 变量++：先返回再自增
   >    3. 特殊情况：变量++  +  ++变量时候   注意：第一个变量原值计算  第二个变量是在第一个自增后的返回值之后再进行自增
   > 3. 比较运算符：
   >    1. '>='   '<='   '=='    '!='    会把数值型字符串隐式转化
   > 4. 逻辑运算符：&& 与    || 或     ！非
   >    1. &&  一假即假
   >    2. ||  一真即真
   >    3. ！ 真的对立    假的对立（非假即真  非真即假）
   >    4. 短路运算：
   >       1. &&  第一个值为真返回后面值 ； 第一个值为假（上面提到的布尔值）返回第一个值（不管后面多少个值）
   >       2. ||   第一个值是真的返回第一个    如果是假的返回第二个
   >       3. 特殊情况  ：   true类型  ||  0自增    直接返回true类型
   >    5. 赋值运算：  =   +=  -=  *=  /=  %=

4. 流程控制

   **判断**

   > * ​	分支
   >   * 条件分支语句：if（）{}
   >   * 条件双分支  if（）{}else{}
   >   * 多条件分支  if（）{} else if（）{}else{}
   > * 三元表达式  
   >   * 条件表达式 ？ 返回值1 ： 返回值2
   >   * 案例：时间在个位数时候需要补0
   > * switch
   >   * switch（表达式：value值）{   case value： 执行语句 ；break；  default：执行最后语句}

**循环** ：for循环知道循环次数不适合做真假：适合搭配break湖泊这containue  while可以搭配字符串做出真假跳出效果

> * for循环：for（初始变量；条件表达hi；操作表达式【计数器】）{ 循环体； }   配合判断语句使用
>   * 1-100平均数
>   * 1-100奇数偶数之和利用分支语句求奇数之和和偶数之和（1-100以内）
>   * 1-100能被3整除的数之和
>   * 案例：求出班级所有学生成绩综合和平均成绩：定义好各个数据的变量之后；输入每一个学生成绩进行求和计算
>   * 案例：打印一行五颗星 定义变量是空字符串  循环一次加上一个五角星
> * 双重for循环：for(初始变量；条件表达式；计数器){循环体； for（初始变量；条件表达式；计数器）{循环体；}}
>   * 案例：五行五角星：i：外循环设置好初始表达式，j：内循环设置好初始表达式，内存循环做完之后进行换行
>   * 案例：
>     * 倒三角：内环初始值等于外环初始值
>     * 正三角：内循环条件值等于外循环初始值
>     * 99乘法表：内循环条件值等于外循环初始值、加上字符串拼接、注意转义符的使用
> * while循环：while (条件表达式) { 循环体；  计数器；}：带有一丝分支的味道
>   * 求和：首先初始化变量，判断是否满足表达式，然后执行循环体、再进行计数器
>   * 判断：while中的条件就是判断条件
> * do-while循环：初始化变量，do{循环体；计数器}while（循环条件）；
> * containue 、 break（跳出整个循环）

5. 数组   变量 =[多个数组元素：逗号隔开 ]

   > 1. 创建数组：new Array（）； 、直接初始化[ ]；、
   >
   > 2. 访问数组：数组变量 [ 数组元素下标]
   >
   > 3. 遍历数组：搭配for循环  在一致数组下标的情况下，不知道使用数组长度.length
   >
   >    1. 谨记数组元素是从一开始计数
   >    2. 数组元素下标实从0开始计数
   >
   > 4. 数组数据求平均数：声名数组元素和的存储变量和平均数存储变量，再进行遍历求和，最后遍历完进行求平均数，除去数组元素长度
   >
   > 5. 数组最大值：初始化最大数组元素变量时数组下标0哪个数组元素，在遍历数组过程中进行判断赋值
   >
   > 6. 数组转化为分割字符串：不论数组元素是数值还是字符串
   >
   >    * 先进行数组元素赋值初始化变量、初始化替换的分隔符
   >    * 进行遍历并进行赋值
   >
   > 7. 数组增加元素：
   >
   >    1. 增长数组length，如果没有给予数组元素 那么就默认undefined
   >    2. 直接使用数组并默认增加下标并赋值
   >    3. 可以直接使用数组下标赋值替换原来数组的元素
   >
   >    * 案例：利用循环给数组增加元素案例：直接使用计数变量作为数组下标再进行计算表达式最后输出
   >
   > 8. 筛选数组：把就数组中筛选出来的数组元素放到新数组
   >
   >    1. 利用新数组下标 j++计数器进行遍历赋值：每一个旧数组筛选出来的数组元素放在新数组自增后的[ j ]里面
   >
   >    2. length筛选
   >
   >       旧数组；创建新数组
   >
   >       遍历数组，判断，旧数组赋值给新数组length，输出
   >
   > 9. 删除指定数组元素：筛选数组的一种方式
   >    1. 初始化新数组，遍历数组，
   >    2. 判断删除哪些数组元素
   >    3. 再进行赋值到新数组上
   > 10. 反转数组：
   >     1. 遍历数组
   >     2. 调整循环池化变量以及表达式（从旧数组的最后开始往前进行递减）
   >     3. 再进行赋值到新数组，输出
   > 11. 冒泡排序：例如：5，4，3，2，1转换成1，2，3，4，5
   >     1. 首先需要了解交换变量--引申到交换数组元素
   >     2. 外层管趟数（趟数一定是比数组元素少一个）、内层管每趟次数（次数也会随着趟数减少次数减少一个）
   >     3. 测i曾循环一次就执行以此判断：是否后一个数组元素大于或者小于前面数组元素，然后进行数组元素更换![1675178682313](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675178682313.png)

6. 函数：封装一段可以重复调用的代码块为了重复使用：例如冒泡排序重复使用

   > 1. 声明函数：function 函数名（形参：接收实参的）{函数体}
   >
   > 2. 调用函数：函数名（实参）
   >
   > 3. 参数
   >
   >    1. 使用方式：调用函数时侯会把实参传递到形参
   >
   >    * 可以没有参数：直接在函数体里执行输出或者输入语句
   >    * 添加形参和实参：好处可以多次调用并搭配不同的实参
   >
   > 4. 封装1-100累加求和
   >
   > 5. 封装计算功能+任意两个数之间的数值累加求和
   >
   > 6. 形参和实参匹配问题：
   >
   >    * 实参=形参：正常调用输出
   >    * 实参>形参：直会运行形参存在地方
   >    * 实参<形参：表示形参会有参数未定义（undefined）这时候如果是计算就睡出现：NAN
   >
   > 7. 返回值：（相当于替换了输出控制台语句但是又可以输出到调用处）
   >
   >    * 函数只是实现某种功能；最终的结果要返回给函数的调用者；通过return实现
   >    * return使用：只要函数遇到return，就把结果返回给函数调用者![1675181334346](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675181334346.png)
   >    * 封装调用函数比较两个数值大小
   >    * 封装数组遍历求最大值
   >      * 先初始化最值数组值
   >      * 遍历数组
   >      * 根据遍历进行判断并赋值
   >      * 最后return结果
   >    * 注意终止函数效果：
   >      * return之后的js语句不会执行
   >      * 传入多个参数时候，return只会返回最后一个参数值
   >      * 可以返回：数组中传参并计算两个参数的计算结果的数组
   >      * 如果函数没有return还尽心那个调用那么就会返回未定义：undefined
   >
   > 8. arguments：不知道多少实参的情况下直接使用相当于伪数组
   >
   >    * 未定义函数的形参
   >    * 传入多个实参
   >    * 这个时候直接使用arguments
   >      * 包含数组属性：length，【下标】、遍历方式
   >    * 利用arguments求最值：方法和数组求最值方法一样
   >      * 先初始化arguments最值【0】
   >      * 遍历、比较、赋值
   >
   > 9. 封装反转数组元素函数
   >
   > 10. 封装冒泡排序
   >
   > 11. 封装查询闰年：返回输出  true  或者 false
   >
   > 12. 函数之间的调用：需要哦一步一步去观察：js语句从上往下、
   >
   >     * 案例：输入年份得出结果是或否是闰年
   >
   > 13. 函数命名方式
   >
   >     1. 根据关键字直接命名：  function name（）{}
   >     2. 定义变量名代替name： var name = function（）{}
   >        1. 函数表达式声明方式和声明变量差不多，只不过变量是值，而函数表达式里面存放的是函数。
   >

7. 作用域

> 作用域：就近原则（在某个范围内起作用）
>
> 1. 全局作用域：全局变量（函数中没有赋值直接使用也叫做全局变量）只有在关闭浏览器才会销毁，比较占内存
> 2. 局部作用域：局部变量当我们程序执行完成之后就会销毁，比较节约资源
>
> * 代码在使用过程中至少存在一个作用域
> * 写在函数内叫局部作用域
> * 如果函数中还有函数那么这个作用域可以产生一个作用域链
>
> 块级作用域：es6存在：表示作用域在{}包含

 8. 预解析（面试考核点）

    > **1.预解析**
    >       js引擎会把js里面的所有的var 还有function提升到当前作用域最前面![1675224406679](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675224406679.png)
    >
    > * 变量提升（预解析）
    > * 函数提升（预解析）
    >
    > **2.代码执行**
    >       按照代码书写顺序从上往下开始运行
    >
    > * 案例：
    >
    > ![1675224858768](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675224858768.png)

9. 对象：对象是一个具体的对象，看得见摸得着的实物

   > 作用：多个数据使用数组，多个不同属性的数组使用对象
   >
   > 1. 创建对象
   >
   >    1. 字面量：键值对赋值
   >    2. new Object创建对象：等号赋值
   >    3. 构造函数生成对象：this搭配new使用  
   >
   >    * 构造函数不是对象：特指某一大类别，搭配new函数名可以返回一个对象
   >    * 相当于函数创建好一个对象大类。new一下进行对象实例化
   >    * 注意：调用方法时候单独调用生成实例化
   >   
   >         ​	function 构造函数名(多个参数) {
   >   
   >         ​        	this.属性 = 参数;
   >   
   >         ​	        this.方法 = function (参数) {};
   >   
   >       ​	      }
   >
   >    ​	      new 构造函数名();
   >
   >    4. 遍历对象：定义好对象obj：
   >       * 遍历方法：for（var k    in   对象）{输出变量k  ；   输出变量属性值obj[k]}

   10. 内置对象

> **解释**  ：js为程序员提供实现效果不需要知道原理的内置对象
>
> **查阅文档** ：https://developer.mozilla.org/zh-CN/
>
> 1. **Math** ：
>
>    * .abs
>      * 绝对值：负得正，正得负
>      * 强制转换：转换成数字，负值（""  []  ）转换成0     一个数组元素转换成数值  多个数组元素转换成nan、不可直接转换成数值得就是nan  
>    * .floor
>      * 向下取整
>      * 例如：1.4取1、2.9取2、-5.6取-6
>    * .ceil
>      * 向上取整
>      * 例如：1.4取2、2.9取3、-5.6取-5
>    * .round
>      * 四舍五入
>      * 例如：1.1取1、1.5取2、-1.1取-1、
>      * 特殊：（取较大值）-1.5取-1、-1.6取-2
>    * .random
>      * 0-1不等于一得随机数
>      * 返回：（随机数*最大值-最小值+1）再加上最小值最后向下取整![1675237244740](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675237244740.png)
>      * 点名：采用（两数之间）随机数取整方法进行置放再数组中
>      * 猜数字游戏：while循环加上分支判断配合break
>
> 2. **Date**
>
>    * 所有调用date内置函数必须先创建一个新的Date
>    * 配合参数
>      * 没有参数的话显示计算机当前的时间:注意月份（0-11），周（0-6：0是周末）
>      * 参数写法：年，月，日  （不屑默认00：00：00）或者   ‘年-月-日 时：分：秒’
>    * 返回值：格式化当前的时间
>      * 年：date.getFullYear()
>      * 月：date.getMonth() + 1
>      * 周：date.getDay()
>      * 日：date.getDate()
>      * 时：date.getHours()
>      * 分：date.getMinutes()
>      * 秒：date.getSeconds()
>    * 获得时间戳：表示自 1970 年 1 月 1 日 00:00:00 UTC（the Unix epoch）以来的毫秒数
>    * 参数表示参数时间到指定时间过去的毫秒数
>      * date.valueOf()
>      * date.getTime()
>      * var date1 = +new Date(); 
>      * 最简单：Date.now()
>      * 案例：倒计时秒杀效果
>        * 构造一个函数包含
>          * 先进行获取时间戳：指定时间毫秒数、当前时间毫秒数
>          * 再进行换算单位计算：计算中间差多少毫秒数再进行转换成秒
>          * 天：数据类型转换成整数（秒/60/60/24）三元转换 看需要补零不
>          * 时：数据类型转换（（秒/60/60）%24）三元转换 看需要补零不
>          * 分：数据类型转换（（秒/60/）%60）三元转换 看需要补零不
>          * 秒：数据类型转换（秒%60）三元转换 看需要补零不
>        * 输出（调用函数（参数：活动结束时间））
>
> 3. **数组**
>
>    1. 定义数组：
>
>       * new Array（value1）：直接生成value1个空元素的数组
>       * new Array（value1，value1）：直接生成数组元素是value1，value2的数组
>
>    2. 转成字符串并用什么隔开：数组变量.join("转换后的分割符号")
>
>    3. 检测数组：两种方式都会有一个返回值true或者false 
>
>       * 变量 instanceof Array
>       * Array.isArray( 变量 )
>       * 案例：封装数组位置反转
>         * 封装函数
>         * 判断传进来的参数是不是数组
>         * 判断：
>           * 如果是数组进行反转数组（遍历+替换赋值）返回最终值
>           * 不是直接返回语句”不是参数“
>
>    4. 添加或删除：直接调用内置返回的是数组的长度，显示数组得重新输出数组
>
>       1. 里面的参数表示删除或者添加的数值
>
>       * arr.push()：直接再数组末尾添加数组元素
>       * arr.unshift():直接在数组最开始添加数组元素
>       * arr.pop()：直接删除数组最后的元素
>       * arr.shift()：直接删除数组最开始的元素
>
>       1. 案例：筛选数组
>          * 老数组
>          * 新数组
>          * 遍历循环老数组是否满足，不满足直接添加到新数组
>       2. 案例：数组排序
>          1. 反转数组：arr.reserve();
>          2. 冒泡排序：arr.sort();
>             1. 最好使用方式：arr.sort(函数带参a、b，直接返回值a-b就是升序，直接b-a就是降序)
>       3. 数组索引（查找数组元素下标）如果查不到就会返回-1
>          * indexOf：从前往后第一个出现的数组下标
>          * lastIndexOf：从后往前第一个出现的数组下标
>          * 案例：索引配合旧数组遍历去重添加到新数组![1675271876898](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675271876898.png)
>
> 4. **字符串** ：也有lemngth属性
>
>    1. indexOf:根据字符串获得下标：包含两个参数：应用查询某字符串出现某字符的次数  以及分别出现的下标位置
>    
>       1. 根据数组索引查找（参数=查找内容，数值=查找起始位置）![1675272605495](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1675272605495.png)
>       2. 字符串不可变：声明变量赋值  ；再进行变量赋其他值    但是原来的值所开辟空间还在
>       3. 案例：
>          1. 直接查询字符下标（字符）
>          2. 查询字符串下标：indexOf（字符，其实下摆哦位置）
>       4. 统计某个字符串显得次数（数组同样可以使用）
>          * 声名字符串
>          * 声名查询变量：返回下标位置
>          * 进行循环：while（查询条件是否满足没有查到）
>            * 满足下标直接输出一次位置
>            * 然后进行统计次数
>            * 再进行修改表达式条件：利用第二个参数进行+1，然后继续循环
>    
>    2. charAt（数值）：根据数值下标查询对应字符
>    
>    3. charCodeAt(数值)：根据数值下标查询对应字符串斌返回sacii码：常用在反馈用户按键的使用跟踪
>    
>    4. 字符串[下标数值]：类似于数组也可以进行查询到对行书之下的字符
>    
>    5. 案例：统计出现次数最多的字符
>    
>       1. 先遍历进行字符转化成对象
>          * 循环字符串
>          * 字符串内置查询字符给一个变量
>          * 判断对象的下标内置查询是否存在（存在就进行+1；不存在就进行++）
>          * 输出对象（以上已经统计好哪一个字符出现了几次）
>          * 使用  for（ var k in 对象）进行遍历（直接根据对象属性判断之后进行赋值给最大值）
>            * k得到属性名字
>            * 对象[k]得到属性值：这个属性值进行赋值给变量max
>    
>    6. 拼接字符串内置：字符串变量.concat(拼接内容"")
>    
>    7. 截取字符串内置：
>    
>       * 字符串变量.substr(起始下标，取值个数)
>    
>       - 字符串变量.slice(起始下标，取值位置（不包含）)
>       - 字符串变量.substrimg(起始下标，取值位置（不包含）)
>    
>    8. 替换字符串
>    
>       * 字符串变量.replace（"替换前的字符"，"要替换的字符"）
>       * 案例：替换长字符串中的个别字符
>         * 利用循环
>         * 查询下标
>         * 直接赋给原字符串
>    
>    9. 内置字符串转换成数组;
>    
>       * 字符串变量.split("字符串的间隔符号")
>    
>    10. 内置转换成大小写
>    
>        * 字符串变量.toUpperCase()：大写
>        * 字符串变量.toLowerCase()：小写

11. 简单和复杂数据类型

    > 1. 区分：
    >    * 简单：string、number、boolean、undefined、null(最特殊：返回object)
    >    * 复杂：new创建的对象（系统对象、自定义对象）Object、Array、Date![img](https://cdn.nlark.com/yuque/0/2022/png/33610899/1670575418185-b078a0f6-6841-435e-8584-3469de776286.png)
    > 2. 传参并调用
    >    * 简单：直接在栈里面弄进行存放

1. 1. ![img](https://cdn.nlark.com/yuque/0/2022/png/33610899/1670576128064-ea6326c9-3c0c-4b31-9069-26b7018b04da.png)

   2. * 复杂：谁调用先找谁   如果函数调用构造函数创建的对象那么函数的参数地址就和对象的地址一样
      * 注意调用时候看地址的指向方向

![img](https://cdn.nlark.com/yuque/0/2022/png/33610899/1670576986103-73790723-6b5a-434f-9b98-ca66515c5567.png)

